/* TYPES */

import type { AstObject } from "./parse.ts";
import type { Chuck } from "./core.ts";

/* END TYPES */

/**
 * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result
 */

export function compileToString(
  this: Chuck,
  str: string,
): string {
  const config = this.config;
  const compileBody = this.compileBody;
  const buffer: Array<AstObject> = this.parse.call(this, str);

  // note: when the include function passes through options
  let res = `${config.functionHeader}
let include = (template, data) => this.render(template, data, options);

let __chuck = {res: "", e: this.config.escapeFunction, f: this.config.filterFunction${
    config.debug
      ? ', line: 1, templateStr: "' +
        str.replace(/\\|"/g, "\\$&").replace(/\r\n|\n|\r/g, "\\n") +
        '"'
      : ""
  }};

function layout(path, data) {
  __chuck.layout = path;
  __chuck.layoutData = data;
}${config.debug ? "try {" : ""}${
    config.useWith ? "with(" + config.varName + "||{}){" : ""
  }

${compileBody.call(this, buffer)}
if (__chuck.layout) {
  __chuck.res = include (__chuck.layout, {...${config.varName}, body: __chuck.res, ...__chuck.layoutData});
}
${config.useWith ? "}" : ""}${
    config.debug
      ? "} catch (e) { this.RuntimeErr(e, __chuck.templateStr, __chuck.line) }"
      : ""
  }
return __chuck.res;
`;

  return res;
}

/**
 * Loops through the AST generated by `parse` and transform each item into JS calls
 *
 * **Example**
 *
 * ```js
 * let templateAST = ['Hi ', { val: 'it.name', t: 'i' }]
 * compileBody.call(Eta, templateAST)
 * // => "__chuck.res+='Hi '\n__chuck.res+=__chuck.e(it.name)\n"
 * ```
 */

export function compileBody(this: Chuck, buff: Array<AstObject>): string {
  const config = this.config;

  let i = 0;
  const buffLength = buff.length;
  let returnStr = "";

  for (i; i < buffLength; i++) {
    const currentBlock = buff[i];
    if (typeof currentBlock === "string") {
      const str = currentBlock;

      // we know string exists
      returnStr += "__chuck.res+='" + str + "'\n";
    } else {
      const type = currentBlock.t; // "r", "e", or "i"
      let content = currentBlock.val || "";

      if (config.debug) returnStr += "__chuck.line=" + currentBlock.lineNo + "\n";

      if (type === "r") {
        // raw

        // Apply Twig-like filters if present
        if ((currentBlock as any).filters && (currentBlock as any).filters.length > 0) {
          const filterChain = JSON.stringify((currentBlock as any).filters);
          content = `this.applyFilters(${content}, ${filterChain})`;
        } else if (config.autoFilter) {
          content = "__chuck.f(" + content + ")";
        }

        returnStr += "__chuck.res+=" + content + "\n";
      } else if (type === "i") {
        // interpolate

        // Apply Twig-like filters if present
        if ((currentBlock as any).filters && (currentBlock as any).filters.length > 0) {
          const filterChain = JSON.stringify((currentBlock as any).filters);
          content = `this.applyFilters(${content}, ${filterChain})`;
        } else if (config.autoFilter) {
          content = "__chuck.f(" + content + ")";
        }

        if (config.autoEscape) {
          content = "__chuck.e(" + content + ")";
        }

        returnStr += "__chuck.res+=" + content + "\n";
      } else if (type === "e") {
        // execute
        if (currentBlock.assignment) {
          // Handle assignment with filters
          const { varKeyword, varName, value, filters } = currentBlock.assignment;
          const filterChain = JSON.stringify(filters);
          returnStr += `${varKeyword} ${varName} = this.applyFilters(${value}, ${filterChain})\n`;
        } else {
          returnStr += content + "\n";
        }
      }
    }
  }

  return returnStr;
}
